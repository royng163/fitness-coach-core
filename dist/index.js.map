{"version":3,"sources":["../src/preprocess.ts","../src/metrics.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["export interface LetterboxParams {\n  inputSize: number;       // model square input (e.g., 256/384/640)\n  scale: number;           // scale applied to src -> resized\n  dx: number;              // left padding in pixels in model input space\n  dy: number;              // top padding in pixels in model input space\n  resized: { width: number; height: number };\n}\n\n/**\n * Compute centered letterbox to fit src into a square inputSize.\n * Returns scale and padding for accurate coordinate unprojection.\n */\nexport function computeLetterbox(srcW: number, srcH: number, inputSize: number): LetterboxParams {\n  const s = Math.min(inputSize / srcW, inputSize / srcH);\n  const newW = Math.round(srcW * s);\n  const newH = Math.round(srcH * s);\n  const dx = Math.floor((inputSize - newW) / 2);\n  const dy = Math.floor((inputSize - newH) / 2);\n  return { inputSize, scale: s, dx, dy, resized: { width: newW, height: newH } };\n}\n\n/**\n * Map point from model input space back to original source pixel space.\n * If model outputs normalized coords [0..1], set normalized=true.\n */\nexport function mapFromLetterbox(\n  x: number,\n  y: number,\n  srcW: number,\n  srcH: number,\n  p: LetterboxParams,\n  normalized = false\n): { x: number; y: number } {\n  const px = normalized ? x * p.inputSize : x;\n  const py = normalized ? y * p.inputSize : y;\n  const ox = Math.max(0, Math.min(srcW, (px - p.dx) / p.scale));\n  const oy = Math.max(0, Math.min(srcH, (py - p.dy) / p.scale));\n  return { x: ox, y: oy };\n}\n\n/**\n * Per-channel mean/std normalization into Float32Array.\n * Assumes packed RGB byte data (no alpha).\n */\nexport function normalizeUint8ToFloat32(\n  src: Uint8Array,\n  mean: [number, number, number] = [0, 0, 0],\n  std: [number, number, number] = [1, 1, 1]\n): Float32Array {\n  const out = new Float32Array(src.length);\n  for (let i = 0; i < src.length; i += 3) {\n    out[i] = (src[i] / 255 - mean[0]) / std[0];\n    out[i + 1] = (src[i + 1] / 255 - mean[1]) / std[1];\n    out[i + 2] = (src[i + 2] / 255 - mean[2]) / std[2];\n  }\n  return out;\n}","import type { Keypoint } from './types';\n\n/**\n * Percentage of Correct Keypoints relative to bbox diagonal threshold.\n */\nexport function pck(\n  pred: Keypoint[],\n  gt: Keypoint[],\n  bboxDiagPixels: number,\n  alpha = 0.1\n): number {\n  const n = Math.min(pred.length, gt.length);\n  if (n === 0 || bboxDiagPixels <= 0) return 0;\n  const thr = alpha * bboxDiagPixels;\n  let correct = 0;\n  for (let i = 0; i < n; i++) {\n    const dx = pred[i].x - gt[i].x;\n    const dy = pred[i].y - gt[i].y;\n    if (Math.hypot(dx, dy) <= thr) correct++;\n  }\n  return correct / n;\n}"]}